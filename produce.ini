[]
train = java -classpath bin epar.Train
decode = java -classpath bin epar.Decode
TreesToActionSequences = java -classpath bin epar.TreesToActionSequences
shell = bash
prelude =
	def count_lines(filename):
		result = 0
		with open(filename) as f:
			for line in f:
				result += 1
		return result

## PARSEVAL EVALUATION ########################################################

[output/%{exp}/eval.%{i}.txt]
dep.output = output/%{exp}/output.%{i}.txt
dep.reference = data/%{exp}/reference.txt
dep.eval = scripts/eval.py
recipe = ./%{eval} %{reference} %{output} > %{target}

## DEPENDENCY EVALUATION ######################################################

# This only works for the original wsj experiment because the other experiments
# are not compatible with generate. We do this to verify we are in the same
# accuracy ballpark as Zhang and Clark (2011).

# TODO should exclude rules like Zhang and Clark (2011) to make sure we
# evaluate on the full set.

[output/wsj/depeval.%{i}.txt]
dep.filtered_ccgbank_deps = output/wsj/output.%{i}.filtered.ccgbank_deps
dep.reference_filtered_stagged = output/wsj/reference.%{i}.filtered.stagged
dep.reference_filtered_ccgbank_deps = output/wsj/reference.%{i}.filtered.ccgbank_deps
dep.evaluate = ext/candc/src/scripts/ccg/evaluate
recipe = %{evaluate} %{reference_filtered_stagged} %{reference_filtered_ccgbank_deps} %{filtered_ccgbank_deps} > %{target}

[output/wsj/reference.%{i}.filtered.%{x}]
cond = %{x in ('stagged', 'ccgbank_deps')}
deps = output/wsj/output.%{i}.filtered.ccgbank_deps

[output/wsj/output.%{i}.filtered.ccgbank_deps]
dep.ccgbank_deps = output/wsj/output.%{i}.ccgbank_deps
dep.reference_stagged = data/wsj/reference.stagged
dep.reference_ccgbank_deps = data/wsj/reference.ccgbank_deps
reference_filtered_stagged = output/wsj/reference.%{i}.filtered.stagged
reference_filtered_ccgbank_deps = output/wsj/reference.%{i}.filtered.ccgbank_deps
outputs = %{reference_filtered_stagged} %{reference_filtered_ccgbank_deps}
recipe = ./scripts/filter_ccgbank_deps %{reference_stagged} %{reference_ccgbank_deps} %{ccgbank_deps} %{reference_filtered_stagged} %{reference_filtered_ccgbank_deps} %{target}

[output/wsj/output.%{i}.ccgbank_deps]
depfile = output/wsj/output.%{i}.ccgbank_deps.d
dep.output = output/wsj/output.%{i}.txt
recipe =
	rm -f %{target}
	echo '#' >> %{target}
	echo '#' >> %{target}
	echo '' >> %{target}
	for j in $(zsh -c 'echo {1..$(cat %{output} | wc -l)}')
	do
		cat tmp/wsj/output.%{i}.ccgbank_deps.part.$j >> %{target}
	done

[output/wsj/output.%{i}.ccgbank_deps.d]
dep.output = output/wsj/output.%{i}.txt
recipe =
	rm -f %{target}
	for j in $(zsh -c 'echo {1..$(cat %{output} | wc -l)}')
	do
		echo tmp/wsj/output.%{i}.ccgbank_deps.part.$j >> %{target}
	done

[tmp/wsj/output.%{i}.ccgbank_deps.part.%{j}]
dep.text = tmp/wsj/output.%{i}.text.part.%{j}
dep.ccgbank_deps_formatted = tmp/wsj/output.%{i}.ccgbank_deps.formatted.part.%{j}
dep.cat = tmp/wsj/output.%{i}.cat.part.%{j}
recipe =
	if [ `cat %{text} | grep '__PARSE_FAILED__' | wc -l | cut -d\  -f 1` == 0 ]
	then
		grep ^[^\#] %{ccgbank_deps_formatted} | cat > %{target}
		./scripts/merge_fragmented_cats %{cat} >> %{target}
	else
		echo bin/generator failed
		echo '' > %{target}
	fi

[tmp/wsj/output.%{i}.text.part.%{j}]
dep.pipe_fragmented = tmp/wsj/output.%{i}.pipe.fragmented.part.%{j}
recipe =
	./ext/candc/bin/generate -T ext/candc/src/data/ccg/cats ext/%{candc}/src/data/ccg/cats/markedup %{pipe_fragmented} > %{target} 2> %{target}.log

[tmp/wsj/output.%{i}.ccgbank_deps.formatted.part.%{j}]
dep.ccgbank_deps_without_cats = tmp/wsj/output.%{i}.ccgbank_deps.without_cats.part.%{j}
dep.pipe_fragmented = tmp/wsj/output.%{i}.pipe.fragmented.part.%{j}
dep.cat = tmp/wsj/output.%{i}.cat.part.%{j}
recipe = ./scripts/merge_fragmented_deps %{ccgbank_deps_without_cats} %{pipe_fragmented} %{cat} > %{target}

[tmp/wsj/output.%{i}.ccgbank_deps.without_cats.part.%{j}]
dep.pipe_fragmented = tmp/wsj/output.%{i}.pipe.fragmented.part.%{j}
recipe = ./ext/candc/bin/generate -j ext/candc/src/data/ccg/cats ext/candc/src/data/ccg/cats/markedup %{pipe_fragmented} > %{target} 2> %{target}.log

[tmp/wsj/output.%{i}.cat.part.%{j}]
deps = tmp/wsj/output.%{i}.pipe.fragmented.part.%{j}

[tmp/wsj/output.%{i}.pipe.fragmented.part.%{j}]
dep.pipe = tmp/wsj/output.%{i}.pipe.part.%{j}
cat = tmp/wsj/output.%{i}.cat.part.%{j}
outputs = %{cat}
recipe = 
	set -e
	set -o pipefail
	python ext/zpar/scripts/ccg/pipe.py split %{pipe} %{cat} %{target}

[tmp/wsj/output.%{i}.pipe.part.%{j}]
dep.output = tmp/wsj/output.%{i}.txt.part.%{j}
recipe = python scripts/zpar2pipe.py -op %{output} > %{target}
	
[tmp/wsj/output.%{i}.txt.part.%{j}]
dep.output = output/wsj/output.%{i}.txt
recipe =
	set -e
	(cd tmp; mkdir -p wsj)
	cat %{output} | head -%{j} | tail -1 > %{target}

## CONVERTING TO DEPENDENCIES #################################################
# TODO

## DECODING ###################################################################

[output/%{exp}/output.rules1.txt]
model = output/%{exp}/model.10
dep.input = data/%{exp}/input.txt
dep.binary_train = data/%{exp}/rules.binary
dep.unary_train = data/%{exp}/rules.unary
dep.binary = output/%{exp}/rules.rules1.binary
dep.unary = output/%{exp}/rules.rules1.unary
recipe =
	mkdir -p output/%{exp}
	# HACK training data for translating between strings and numbers
	%{decode} data/%{exp}/train.input output/%{exp}/oracles %{binary_train} %{unary_train} %{binary} %{unary} %{model} %{input} 16 %{target} 2> %{target}.log

[output/%{exp}/output.%{i}.txt]
model = output/%{exp}/model.%{i}
dep.input = data/%{exp}/input.txt
dep.binary_train = data/%{exp}/rules.binary
dep.unary_train = data/%{exp}/rules.unary
dep.binary = data/%{exp}/rules.binary
dep.unary = data/%{exp}/rules.unary
recipe =
	mkdir -p output/%{exp}
	# HACK training data for translating between strings and numbers
	%{decode} data/%{exp}/train.input output/%{exp}/oracles %{binary_train} %{unary_train} %{binary} %{unary} %{model} %{input} 16 %{target} 2> %{target}.log

## TRAINING ###################################################################

[output/%{exp}/model.0]
recipe =
	mkdir -p output/%{exp}
	touch %{target}

[output/%{exp}/oracles]
dep.txt = data/%{exp}/train.txt
dep.binary = data/%{exp}/rules.binary
dep.unary = data/%{exp}/rules.unary
recipe =	
	mkdir -p output/%{exp}
	%{TreesToActionSequences} %{txt} %{binary} %{unary} > %{target}

[output/%{exp}/model.%{i}]
dep.oracles = output/%{exp}/oracles
dep.input = data/%{exp}/train.input
dep.binary = data/%{exp}/rules.binary
dep.unary = data/%{exp}/rules.unary
recipe =
	mkdir -p output/%{exp}
	%{train} %{input} %{oracles} %{binary} %{unary} %{i} output/%{exp}/model 2> %{target}.log

## DATA #######################################################################

# TODO this is now all automatically generated or imported from external
# project, could go in output directory.

[data/wsj/input.txt]
recipe =
	set -o pipefail
	cat ext/supertagging/out/ccgbank00.automultistagged | ./scripts/msuper2zpar > %{target}

[data/wsj/rules.%{x}]
dep.rules = grammar/rules.%{x}
recipe =
	mkdir -p data/wsj
	cp grammar/rules.%{x} data/wsj

[data/wsj/reference.stagged]
dep.pipe = data/wsj/reference.pipe
recipe = ./ext/candc/src/scripts/ccg/extract_sequences -s %{pipe} > %{target}

[data/wsj/reference.pipe]
recipe =
	mkdir -p data/wsj
	./ext/candc/src/scripts/ccg/convert_auto ext/CCGbank1.2/data/AUTO/00/*.auto | sed 's|((S\[b\]\\NP)/NP)/ |(S[b]\\NP)/NP |g' | sed -f ext/candc/src/scripts/ccg/convert_brackets > %{target}

[data/wsj/reference.ccgbank_deps]
dep.parg = data/wsj/reference.parg
recipe = ./ext/candc/src/scripts/ccg/parg2ccgbank_deps %{parg} > %{target}

[data/wsj-straight-markedup/reference.ccgbank_deps]
dep.ccgbank_deps = data/wsj/reference.ccgbank_deps
recipe = cat %{ccgbank_deps} | ./scripts/straighten_ccgbank_deps.py > %{target}

[data/wsj/reference.parg]
recipe = cat ext/CCGbank1.2/data/PARG/00/*.parg | sed -f ext/candc/src/scripts/ccg/convert_brackets > %{target}

[data/wsj/train.txt]
recipe =
	set -o pipefail
	mkdir -p data/wsj
	# convert to pipe format, fix that one broken category, convert brackets, convert to ZPar format
	python ./ext/zpar/scripts/ccg/ccg2zpar.py <(cat ext/CCGbank1.2/data/AUTO/{02..21}/*.auto | ./ext/candc/src/scripts/ccg/convert_auto | sed 's|((S\[b\]\\NP)/NP)/ |(S[b]\\NP)/NP |g' | sed -f ./ext/candc/src/scripts/ccg/convert_brackets) > %{target}

[data/wsj/reference.txt]
recipe =
	set -o pipefail
	mkdir -p data/wsj
	python ./ext/zpar/scripts/ccg/ccg2zpar.py <(cat ext/CCGbank1.2/data/AUTO/00/*.auto | ./ext/candc/src/scripts/ccg/convert_auto | sed -f ./ext/candc/src/scripts/ccg/convert_brackets) > %{target}

[data/wsj-straight-markedup/train.txt]
recipe =
	set -o pipefail
	mkdir -p data/wsj-straight-markedup
	# convert to pipe format, fix that one broken category, convert brackets, convert to ZPar format
	python ./ext/zpar/scripts/ccg/ccg2zpar.py <(cat ext/CCGbank1.2/data/AUTO/{02..21}/*.auto | ./ext/candc/src/scripts/ccg/convert_auto | sed 's|((S\[b\]\\NP)/NP)/ |(S[b]\\NP)/NP |g' | sed -f ./ext/candc/src/scripts/ccg/convert_brackets | ./scripts/pipe_markup.py | ./scripts/pipe_straighten.py) > %{target}

[data/wsj-straight-markedup/reference.txt]
recipe =
	set -o pipefail
	mkdir -p data/wsj-straight-markedup
	python ./ext/zpar/scripts/ccg/ccg2zpar.py <(cat ext/CCGbank1.2/data/AUTO/00/*.auto | ./ext/candc/src/scripts/ccg/convert_auto | sed -f ./ext/candc/src/scripts/ccg/convert_brackets | ./scripts/pipe_markup.py | ./scripts/pipe_straighten.py) > %{target}

[data/wsj-straight/train.txt]
recipe =
	set -o pipefail
	mkdir -p data/wsj
	python ./ext/zpar/scripts/ccg/ccg2zpar.py <(cat ext/CCGbank1.2/data/AUTO/{02..21}/*.auto | ./ext/candc/src/scripts/ccg/convert_auto | sed -f ./ext/candc/src/scripts/ccg/convert_brackets | ./scripts/pipe_straighten.py) > %{target}

[data/wsj/train.input]
# automultistagged file already contains the gold categories where the supertagger did not find them
recipe =
	set -o pipefail
	cat ext/supertagging/out/ccgbank02-21.automultistagged | ./scripts/msuper2zpar > %{target}

# TODO should we be using straight categories with the supertagger?
# Don't think we have to, we're talking about the parsing model. Also in our application, supertagging is done based on English derivations.
[data/wsj-straight-markedup/train.input]
dep.input = data/wsj/train.input
dep.input_markup = scripts/input_markup.py
dep.input_straighten = scripts/input_straighten.py
dep.markup = scripts/markup.py
recipe =
	set -o pipefail
	cat %{input} | ./%{input_markup} | ./%{input_straighten} > %{target}

[data/wsj-straight-markedup/rules.binary]
dep.binary_in = data/wsj/rules.binary
dep.unary_in = data/wsj/rules.unary
binary_out = %{target}
unary_out = data/wsj-straight-markedup/rules.unary
outputs = %{unary_out}
dep.grammar_markup = scripts/grammar_markup.py
dep.grammar = scripts/grammar.py
dep.markup = scripts/markup.py
dep.grammar_straighten = scripts/grammar_straighten.py
recipe =
	./%{grammar_markup} %{binary_in} %{unary_in} %{binary_out}.unstraightened %{unary_out}.unstraightened
	./%{grammar_straighten} %{binary_out}.unstraightened %{unary_out}.unstraightened %{binary_out} %{unary_out}

[data/wsj-straight-markedup/input.txt]
dep.input = data/wsj/input.txt
dep.input_markup = scripts/input_markup.py
dep.input_straighten = scripts/input_straighten.py
dep.markup = scripts/markup.py
recipe =
	set -o pipefail
	cat %{input} | ./%{input_markup} | ./%{input_straighten} > %{target}

[data/wsj/input.txt]
recipe =
	set -o pipefail
	cat ext/supertagging/wsj00.automultistagged | ./scripts/msuper2zpar > %{target}

[data/wsj-straight/input.txt]
recipe = cat ~/dev/supertagging/out/straightbank00.automultistagged | ./scripts/msuper2zpar > %{target}
